<!DOCTYPE html>
<html>
  <head>
    <title>ESP32-CAM Remote Viewer</title>
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"
    />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mqtt/4.3.7/mqtt.min.js"></script>
    <script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsmpeg@1.0.0/jsmpeg.min.js"></script>
    <style>
      html,
      body {
        height: 100%;
        width: 100%;
        margin: 0;
        padding: 0;
        -webkit-overflow-scrolling: touch;
      }

      #videoContainer {
        position: relative;
        max-width: 100%;
        margin: 0 auto;
        padding: 10px;
        box-sizing: border-box;
        overflow: hidden;
      }

      #status {
        position: fixed;
        bottom: 20px;
        left: 0;
        right: 0;
        padding: 10px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        text-align: center;
        z-index: 1000;
        font-family: -apple-system, system-ui, BlinkMacSystemFont, "Segoe UI",
          Roboto, "Helvetica Neue", Arial, sans-serif;
      }

      canvas {
        width: 100%;
        height: auto;
        display: block;
        border: none;
      }

      * {
        -webkit-tap-highlight-color: transparent;
        -webkit-touch-callout: none;
      }

      #detectionResults {
        position: fixed;
        top: 20px;
        left: 20px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 10px;
        border-radius: 5px;
        font-family: -apple-system, system-ui, BlinkMacSystemFont, "Segoe UI",
          Roboto, "Helvetica Neue", Arial, sans-serif;
        z-index: 1000;
      }

      .detection-box {
        position: absolute;
        border: 5px solid red;
        pointer-events: none;
        box-shadow: 0 0 10px rgba(255, 0, 0, 1);
        z-index: 1000;
        background-color: rgba(255, 0, 0, 0.3);
      }

      .detection-label {
        position: absolute;
        background: black;
        color: white;
        padding: 5px 10px;
        font-size: 16px;
        font-weight: bold;
        border-radius: 4px;
        pointer-events: none;
        z-index: 1001;
        white-space: nowrap;
        box-shadow: 0 0 5px black;
        border: 1px solid red;
      }

      #videoStream {
        width: 100%;
        height: auto;
        display: none;
      }

      #rtcVideo {
        width: 100%;
        height: auto;
        display: block;
      }

      #videoCanvas {
        width: 100%;
        height: auto;
        display: block;
      }

      #bufferCanvas {
        display: none;
      }

      #videoCanvas {
        backface-visibility: hidden;
        transform: translateZ(0);
        perspective: 1000;
        will-change: transform;
      }
    </style>
  </head>
  <body>
    <div id="videoContainer">
      <canvas id="videoCanvas"></canvas>
      <div id="detectionResults"></div>
      <p id="status">Conectando...</p>
    </div>

    <button
      id="debugButton"
      style="
        position: fixed;
        bottom: 60px;
        right: 10px;
        z-index: 2000;
        padding: 10px;
        background: red;
        color: white;
        border: none;
        border-radius: 5px;
      "
    >
      Debug
    </button>

    <script>
      const isIOS =
        /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;

      const mqttConfig = {
        clientId: "viewer_" + Math.random().toString(16).substr(2, 8),
        protocol: "wss",
        keepalive: isIOS ? 20 : 30,
        connectTimeout: isIOS ? 15000 : 10000,
        reconnectPeriod: 2000,
        clean: true,
        qos: 0,
        rejectUnauthorized: false,
        will: {
          topic: "esp32cam/stream/status",
          payload: "Viewer disconnected",
          qos: 0,
          retain: false,
        },
      };

      function connectMQTT() {
        try {
          return mqtt.connect("wss://test.mosquitto.org:8081", mqttConfig);
        } catch (e) {
          console.error("Error al conectar:", e);
          status.textContent = "Error de conexión. Reintentando...";
          return null;
        }
      }

      let client = connectMQTT();
      const canvas = document.getElementById("videoCanvas");
      const ctx = canvas.getContext("2d");
      const status = document.getElementById("status");

      let currentFrame = [];
      let expectedChunks = 0;
      let receivedChunks = 0;
      let deviceId = null;
      let reconnectAttempts = 0;
      const MAX_RECONNECT_ATTEMPTS = 3;

      let connectionTimeout = setTimeout(
        () => {
          if (!client?.connected) {
            handleConnectionFailure();
          }
        },
        isIOS ? 20000 : 15000
      );

      function handleConnectionFailure() {
        if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
          status.textContent = "Reintentando conexión...";
          reconnectAttempts++;

          if (client) {
            client.end(true);
          }

          setTimeout(() => {
            client = connectMQTT();
            setupEventListeners();
          }, 2000);
        } else {
          status.textContent =
            "No se pudo establecer conexión. Por favor, recarga la página.";
        }
      }

      // Configuración WebRTC
      const mediaStreamConstraints = {
        video: {
          width: { ideal: 640 },
          height: { ideal: 480 },
          frameRate: { ideal: 30 },
        },
      };

      let mediaRecorder;
      let recordedChunks = [];
      let videoBuffer;
      let sourceBuffer;
      let mediaSource;
      let rtcVideo;

      let jsmpegPlayer;
      let frameBuffer = [];
      const PERFORMANCE_SETTINGS = {
        BUFFER_SIZE: 3,
        FRAME_INTERVAL: 1000 / 30,
        MIN_BUFFER_SIZE: 2,
        MAX_WIDTH: 1280,
        JPEG_QUALITY: 1.0,
        SCALE_FACTOR: 1.0,
        AUTO_ADJUST: false,
        TARGET_FPS: 30,
      };
      let isProcessingBuffer = false;
      let isFirstFrame = true;

      let lastDrawTime = 0;

      let frameTimestamps = [];
      let currentFPS = 0;

      // Crear dos canvas offscreen para double buffering
      const backCanvas = document.createElement("canvas");
      const backCtx = backCanvas.getContext("2d", {
        alpha: false,
        desynchronized: true,
      });

      const frontCanvas = document.createElement("canvas");
      const frontCtx = frontCanvas.getContext("2d", {
        alpha: false,
        desynchronized: true,
      });

      // Función para intercambiar buffers suavemente
      function swapBuffers(imageBitmap) {
        // Preparar el back buffer
        if (
          backCanvas.width !== imageBitmap.width ||
          backCanvas.height !== imageBitmap.height
        ) {
          backCanvas.width =
            frontCanvas.width =
            canvas.width =
              imageBitmap.width;
          backCanvas.height =
            frontCanvas.height =
            canvas.height =
              imageBitmap.height;
        }

        // Dibujar nuevo frame en el back buffer
        backCtx.drawImage(imageBitmap, 0, 0);

        // Copiar back buffer al front buffer
        frontCtx.drawImage(backCanvas, 0, 0);

        // Aplicar una transición suave al canvas visible
        ctx.globalAlpha = 1.0;
        ctx.drawImage(frontCanvas, 0, 0);
      }

      // Función para redimensionar y optimizar frames
      async function optimizeFrame(fullFrame) {
        try {
          const blob = new Blob([fullFrame], { type: "image/jpeg" });
          const imageBitmap = await createImageBitmap(blob);

          // Calcular dimensiones manteniendo aspecto
          let targetWidth =
            imageBitmap.width * PERFORMANCE_SETTINGS.SCALE_FACTOR;
          let targetHeight =
            imageBitmap.height * PERFORMANCE_SETTINGS.SCALE_FACTOR;

          if (targetWidth > PERFORMANCE_SETTINGS.MAX_WIDTH) {
            const ratio = PERFORMANCE_SETTINGS.MAX_WIDTH / targetWidth;
            targetWidth *= ratio;
            targetHeight *= ratio;
          }

          // Usar un canvas temporal para el redimensionamiento
          const tempCanvas = document.createElement("canvas");
          tempCanvas.width = targetWidth;
          tempCanvas.height = targetHeight;
          const tempCtx = tempCanvas.getContext("2d", {
            alpha: false,
            desynchronized: true,
          });

          // Aplicar optimizaciones de renderizado
          tempCtx.imageSmoothingEnabled = true;
          tempCtx.imageSmoothingQuality = "medium";

          // Dibujar frame redimensionado
          tempCtx.drawImage(imageBitmap, 0, 0, targetWidth, targetHeight);

          // Liberar recursos
          imageBitmap.close();

          // Convertir a Blob con calidad ajustada
          const optimizedBlob = await new Promise((resolve) => {
            tempCanvas.toBlob(
              resolve,
              "image/jpeg",
              PERFORMANCE_SETTINGS.JPEG_QUALITY
            );
          });

          // Convertir Blob a ArrayBuffer
          return new Uint8Array(await optimizedBlob.arrayBuffer());
        } catch (error) {
          console.error("Error optimizing frame:", error);
          return fullFrame; // Retornar frame original si hay error
        }
      }

      // Función para calcular y ajustar FPS
      function updateFPS() {
        const now = performance.now();
        frameTimestamps.push(now);

        // Mantener solo los últimos 30 frames para el cálculo
        if (frameTimestamps.length > 30) {
          frameTimestamps.shift();
        }

        if (frameTimestamps.length > 1) {
          const timeElapsed = now - frameTimestamps[0];
          currentFPS = (frameTimestamps.length / timeElapsed) * 1000;

          // Auto-ajuste de calidad basado en FPS
          if (PERFORMANCE_SETTINGS.AUTO_ADJUST) {
            if (currentFPS < PERFORMANCE_SETTINGS.TARGET_FPS - 5) {
              // Reducir calidad si FPS está bajo
              PERFORMANCE_SETTINGS.SCALE_FACTOR = Math.max(
                0.5,
                PERFORMANCE_SETTINGS.SCALE_FACTOR - 0.1
              );
              PERFORMANCE_SETTINGS.JPEG_QUALITY = Math.max(
                0.6,
                PERFORMANCE_SETTINGS.JPEG_QUALITY - 0.1
              );
            } else if (currentFPS > PERFORMANCE_SETTINGS.TARGET_FPS + 5) {
              // Aumentar calidad si FPS está alto
              PERFORMANCE_SETTINGS.SCALE_FACTOR = Math.min(
                1.0,
                PERFORMANCE_SETTINGS.SCALE_FACTOR + 0.1
              );
              PERFORMANCE_SETTINGS.JPEG_QUALITY = Math.min(
                0.9,
                PERFORMANCE_SETTINGS.JPEG_QUALITY + 0.1
              );
            }
          }
        }
      }

      // Modificar processFrame para incluir optimización
      async function processFrame(fullFrame) {
        const currentTime = performance.now();

        if (currentTime - lastDrawTime < PERFORMANCE_SETTINGS.FRAME_INTERVAL) {
          if (frameBuffer.length < PERFORMANCE_SETTINGS.BUFFER_SIZE) {
            frameBuffer.push(fullFrame);
          }
          return;
        }

        lastDrawTime = currentTime;

        try {
          // Optimizar frame antes de procesarlo
          const optimizedFrame = await optimizeFrame(fullFrame);
          const blob = new Blob([optimizedFrame], { type: "image/jpeg" });

          const imageBitmap = await createImageBitmap(blob, {
            imageOrientation: "none",
            premultiplyAlpha: "none",
            colorSpaceConversion: "none",
          });

          requestAnimationFrame(() => {
            swapBuffers(imageBitmap);
            imageBitmap.close();
            updateFPS();

            // Actualizar status con FPS
            status.textContent = `Streaming... Buffer: ${frameBuffer.length}/${
              PERFORMANCE_SETTINGS.BUFFER_SIZE
            } FPS: ${Math.round(currentFPS)}`;
          });

          if (frameBuffer.length > 0) {
            const nextFrame = frameBuffer.shift();
            processFrame(nextFrame);
          }
        } catch (error) {
          console.error("Error processing frame:", error);
        }
      }

      // Optimizar el canvas principal
      ctx.imageSmoothingEnabled = false;
      ctx.mozImageSmoothingEnabled = false;
      ctx.webkitImageSmoothingEnabled = false;
      ctx.msImageSmoothingEnabled = false;

      function setupEventListeners() {
        if (!client) return;

        client.on("connect", () => {
          clearTimeout(connectionTimeout);
          reconnectAttempts = 0;
          console.log("Conectado al broker MQTT");
          status.textContent = "Conectado al broker MQTT, esperando stream...";

          // Suscribirse a los topics necesarios
          const topics = [
            "esp32cam/stream/#",
            "esp32cam/+/metadata",
            "esp32cam/+/frame/#",
          ];

          topics.forEach((topic) => {
            client.subscribe(topic, { qos: 0 }, (err) => {
              if (err) {
                console.error("Error al suscribirse a " + topic + ":", err);
                status.textContent = "Error al suscribirse: " + err.message;
              }
            });
          });
        });

        client.on("close", () => {
          console.log("Desconectado del broker MQTT");
          status.textContent = "Desconectado del broker MQTT. Reconectando...";
        });

        client.on("message", async (topic, message) => {
          try {
            if (topic.endsWith("/metadata")) {
              const metadata = JSON.parse(message.toString());
              deviceId = metadata.deviceId;
              expectedChunks = metadata.chunks;
              currentFrame = new Array(expectedChunks).fill(null);
              receivedChunks = 0;
              status.textContent = `Buffering... (${frameBuffer.length}/${PERFORMANCE_SETTINGS.BUFFER_SIZE})`;
            } else if (topic.includes("/frame/")) {
              const frameIndex = parseInt(topic.split("/").pop());
              currentFrame[frameIndex] = message;
              receivedChunks++;

              if (receivedChunks === expectedChunks) {
                try {
                  // Construir el frame completo
                  const fullFrame = new Uint8Array(
                    currentFrame.reduce((acc, chunk) => acc + chunk.length, 0)
                  );
                  let offset = 0;
                  currentFrame.forEach((chunk) => {
                    if (chunk) {
                      fullFrame.set(chunk, offset);
                      offset += chunk.length;
                    }
                  });

                  // Si el buffer está vacío, procesar inmediatamente
                  if (frameBuffer.length === 0 && !isProcessingBuffer) {
                    if (
                      receivedChunks >= PERFORMANCE_SETTINGS.MIN_BUFFER_SIZE
                    ) {
                      processFrame(fullFrame);
                    } else {
                      frameBuffer.push(fullFrame);
                    }
                  } else {
                    if (
                      frameBuffer.length >= PERFORMANCE_SETTINGS.BUFFER_SIZE
                    ) {
                      // Mantener frames más recientes pero no eliminar demasiados
                      frameBuffer = frameBuffer.slice(
                        -PERFORMANCE_SETTINGS.MIN_BUFFER_SIZE
                      );
                    }
                    frameBuffer.push(fullFrame);
                  }

                  // Procesar detección cada 5 frames usando el último frame completo
                  if (receivedChunks % 5 === 0) {
                    const blob = new Blob([fullFrame], { type: "image/jpeg" });
                    detectObjects(blob).then((result) => {
                      if (result && result.status === "success") {
                        drawDetections(result.detections);
                      }
                    });
                  }

                  // Resetear para el siguiente frame
                  receivedChunks = 0;
                  currentFrame = new Array(expectedChunks).fill(null);
                  status.textContent = `Streaming... Buffer: ${frameBuffer.length}/${PERFORMANCE_SETTINGS.BUFFER_SIZE}`;
                } catch (err) {
                  console.error("Error procesando frame:", err);
                  status.textContent = "Error procesando frame";
                }
              }
            }
          } catch (error) {
            console.error("Error procesando mensaje:", error);
          }
        });

        client.on("error", (error) => {
          console.error("Error MQTT:", error);
          status.textContent = `Error de conexión: ${error.message}. Reintentando...`;
          setTimeout(() => {
            if (!client.connected) {
              location.reload();
            }
          }, 5000);
        });

        client.on("offline", () => {
          console.log("Conexión perdida, intentando reconectar...");
          status.textContent = "Conexión perdida. Reconectando...";
        });

        client.on("reconnect", () => {
          console.log("Intentando reconexión MQTT...");
          status.textContent = "Reconectando al servidor...";
        });
      }

      async function detectObjects(imageBlob) {
        const formData = new FormData();
        console.log("Original image size:", imageBlob.size, "bytes");

        try {
          formData.append("image", imageBlob);
          console.log("Sending detection request to server...");

          const response = await fetch(
            "https://concrete-monkey-selected.ngrok-free.app/detect",
            {
              method: "POST",
              body: formData,
              headers: {
                Accept: "application/json",
              },
            }
          );

          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }

          const result = await response.json();
          console.log("Detection result:", result);

          if (result.detections && result.detections.length > 0) {
            console.log(`Found ${result.detections.length} objects:`);
            result.detections.forEach((det, i) => {
              console.log(
                `  ${i + 1}. ${det.class} (${det.confidence.toFixed(
                  2
                )}) at [${det.bbox.join(", ")}]`
              );
            });
          } else {
            console.log("No objects detected");
          }

          return result;
        } catch (error) {
          console.error("Error en la detección:", error);
          console.error("Error details:", {
            message: error.message,
            stack: error.stack,
            type: error.name,
          });
          return null;
        }
      }

      function clearDetections() {
        const container = document.getElementById("videoContainer");
        // Remove all existing detection boxes and labels from the container
        const boxes = container.querySelectorAll(".detection-box");
        const labels = container.querySelectorAll(".detection-label");

        boxes.forEach((box) => box.remove());
        labels.forEach((label) => label.remove());
      }

      function drawDetections(detections) {
        clearDetections();

        if (!detections || detections.length === 0) return;

        const canvas = document.getElementById("videoCanvas");
        const rect = canvas.getBoundingClientRect();
        const scaleX = rect.width / canvas.width;
        const scaleY = rect.height / canvas.height;

        detections.forEach((detection) => {
          const [x1, y1, x2, y2] = detection.bbox;
          const confidence = Math.round(detection.confidence * 100);

          const scaledX1 = x1 * scaleX;
          const scaledY1 = y1 * scaleY;
          const scaledX2 = x2 * scaleX;
          const scaledY2 = y2 * scaleY;

          const box = document.createElement("div");
          box.className = "detection-box";
          box.style.left = `${scaledX1}px`;
          box.style.top = `${scaledY1}px`;
          box.style.width = `${scaledX2 - scaledX1}px`;
          box.style.height = `${scaledY2 - scaledY1}px`;

          const label = document.createElement("div");
          label.className = "detection-label";
          label.style.left = `${scaledX1}px`;
          label.style.top = `${scaledY1 - 25}px`;
          label.textContent = `${detection.class} ${confidence}%`;

          document.getElementById("videoContainer").appendChild(box);
          document.getElementById("videoContainer").appendChild(label);
        });
      }

      setupEventListeners();

      document.addEventListener("visibilitychange", () => {
        if (document.hidden) {
          if (client?.connected) {
            client.end();
          }
        } else {
          client = connectMQTT();
          setupEventListeners();
        }
      });

      document.addEventListener("gesturestart", (e) => {
        e.preventDefault();
      });

      // Add window resize handler to update bounding boxes
      let resizeTimeout;
      window.addEventListener("resize", () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
          const lastDetections =
            document.querySelector("#videoContainer").__lastDetections;
          if (lastDetections) {
            clearDetections();
            drawDetections(lastDetections);
          }
        }, 250);
      });

      document
        .getElementById("debugButton")
        .addEventListener("click", function () {
          // Crear una detección de prueba
          const testDetections = [
            {
              class: "test",
              confidence: 0.95,
              bbox: [50, 50, 200, 200],
            },
          ];

          // Dibujar la detección de prueba
          drawDetections(testDetections);

          // Mostrar información de depuración
          const canvas = document.getElementById("videoCanvas");
          const rect = canvas.getBoundingClientRect();

          alert(`Debug Info:
        - Canvas size: ${canvas.width}x${canvas.height}
        - Display size: ${rect.width}x${rect.height}
        - Position: ${rect.left},${rect.top}
        - Detections drawn: ${testDetections.length}
        - URL: ${window.location.href}
        - User Agent: ${navigator.userAgent}`);
        });
    </script>
  </body>
</html>
